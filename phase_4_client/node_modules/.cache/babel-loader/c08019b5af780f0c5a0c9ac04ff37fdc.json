{"ast":null,"code":"import _toConsumableArray from \"/Users/mac/Desktop/phase_4_client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/mac/Desktop/phase_4_client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { styled } from '@mui/material/styles';\nimport { defaultMemoize } from 'reselect';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridTabIndexColumnHeaderSelector, gridTabIndexCellSelector, gridFocusColumnHeaderSelector } from '../focus/gridFocusStateSelector';\nimport { gridDensityHeaderHeightSelector, gridDensityHeaderGroupingMaxDepthSelector, gridDensityTotalHeaderHeightSelector } from '../density/densitySelector';\nimport { gridFilterActiveItemsLookupSelector } from '../filter/gridFilterSelector';\nimport { gridSortColumnLookupSelector } from '../sorting/gridSortingSelector';\nimport { gridColumnMenuSelector } from '../columnMenu/columnMenuSelector';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { GridColumnHeaderItem } from '../../../components/columnHeaders/GridColumnHeaderItem';\nimport { getFirstColumnIndexToRender } from '../columns/gridColumnsUtils';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { getRenderableIndexes } from '../virtualization/useGridVirtualScroller';\nimport { GridColumnGroupHeader } from '../../../components/columnHeaders/GridColumnGroupHeader';\nimport { isDeepEqual } from '../../../utils/utils'; // TODO: add the possibility to switch this value if needed for customization\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar MERGE_EMPTY_CELLS = true;\nvar GridColumnHeaderRow = styled('div', {\n  name: 'MuiDataGrid',\n  slot: 'ColumnHeaderRow',\n  overridesResolver: function overridesResolver(props, styles) {\n    return styles.columnHeaderRow;\n  }\n})(function () {\n  return {\n    display: 'flex'\n  };\n});\nfunction isUIEvent(event) {\n  return !!event.target;\n}\nexport var useGridColumnHeaders = function useGridColumnHeaders(props) {\n  var innerRefProp = props.innerRef,\n    _props$minColumnIndex = props.minColumnIndex,\n    minColumnIndex = _props$minColumnIndex === void 0 ? 0 : _props$minColumnIndex;\n  var _React$useState = React.useState(''),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    dragCol = _React$useState2[0],\n    setDragCol = _React$useState2[1];\n  var _React$useState3 = React.useState(''),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    resizeCol = _React$useState4[0],\n    setResizeCol = _React$useState4[1];\n  var apiRef = useGridApiContext();\n  var visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  var columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  var tabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);\n  var cellTabIndexState = useGridSelector(apiRef, gridTabIndexCellSelector);\n  var columnHeaderFocus = useGridSelector(apiRef, gridFocusColumnHeaderSelector);\n  var headerHeight = useGridSelector(apiRef, gridDensityHeaderHeightSelector);\n  var headerGroupingMaxDepth = useGridSelector(apiRef, gridDensityHeaderGroupingMaxDepthSelector);\n  var totalHeaderHeight = useGridSelector(apiRef, gridDensityTotalHeaderHeightSelector);\n  var filterColumnLookup = useGridSelector(apiRef, gridFilterActiveItemsLookupSelector);\n  var sortColumnLookup = useGridSelector(apiRef, gridSortColumnLookupSelector);\n  var columnMenuState = useGridSelector(apiRef, gridColumnMenuSelector);\n  var rootProps = useGridRootProps();\n  var innerRef = React.useRef(null);\n  var handleInnerRef = useForkRef(innerRefProp, innerRef);\n  var _React$useState5 = React.useState(null),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    renderContext = _React$useState6[0],\n    setRenderContext = _React$useState6[1];\n  var prevRenderContext = React.useRef(renderContext);\n  var prevScrollLeft = React.useRef(0);\n  var currentPage = useGridVisibleRows(apiRef, rootProps);\n  React.useEffect(function () {\n    apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;\n  }, [apiRef]); // memoize `getFirstColumnIndexToRender`, since it's called on scroll\n\n  var getFirstColumnIndexToRenderRef = React.useRef(defaultMemoize(getFirstColumnIndexToRender, {\n    equalityCheck: function equalityCheck(a, b) {\n      return ['firstColumnIndex', 'minColumnIndex', 'columnBuffer'].every(function (key) {\n        return a[key] === b[key];\n      });\n    }\n  }));\n  var updateInnerPosition = React.useCallback(function (nextRenderContext) {\n    var _getRenderableIndexes = getRenderableIndexes({\n        firstIndex: nextRenderContext.firstRowIndex,\n        lastIndex: nextRenderContext.lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: currentPage.rows.length,\n        buffer: rootProps.rowBuffer\n      }),\n      _getRenderableIndexes2 = _slicedToArray(_getRenderableIndexes, 2),\n      firstRowToRender = _getRenderableIndexes2[0],\n      lastRowToRender = _getRenderableIndexes2[1];\n    var firstColumnToRender = getFirstColumnIndexToRenderRef.current({\n      firstColumnIndex: nextRenderContext.firstColumnIndex,\n      minColumnIndex: minColumnIndex,\n      columnBuffer: rootProps.columnBuffer,\n      firstRowToRender: firstRowToRender,\n      lastRowToRender: lastRowToRender,\n      apiRef: apiRef,\n      visibleRows: currentPage.rows\n    });\n    var offset = firstColumnToRender > 0 ? prevScrollLeft.current - columnPositions[firstColumnToRender] : prevScrollLeft.current;\n    innerRef.current.style.transform = \"translate3d(\".concat(-offset, \"px, 0px, 0px)\");\n  }, [columnPositions, minColumnIndex, rootProps.columnBuffer, apiRef, currentPage.rows, rootProps.rowBuffer]);\n  React.useLayoutEffect(function () {\n    if (renderContext) {\n      updateInnerPosition(renderContext);\n    }\n  }, [renderContext, updateInnerPosition]);\n  var handleScroll = React.useCallback(function (_ref, event) {\n    var left = _ref.left,\n      _ref$renderContext = _ref.renderContext,\n      nextRenderContext = _ref$renderContext === void 0 ? null : _ref$renderContext;\n    var _prevRenderContext$cu, _prevRenderContext$cu2;\n    if (!innerRef.current) {\n      return;\n    } // Ignore vertical scroll.\n    // Excepts the first event which sets the previous render context.\n\n    if (prevScrollLeft.current === left && ((_prevRenderContext$cu = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu.firstColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.firstColumnIndex) && ((_prevRenderContext$cu2 = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu2.lastColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.lastColumnIndex)) {\n      return;\n    }\n    prevScrollLeft.current = left; // We can only update the position when we guarantee that the render context has been\n    // rendered. This is achieved using ReactDOM.flushSync or when the context doesn't change.\n\n    var canUpdateInnerPosition = false;\n    if (nextRenderContext !== prevRenderContext.current || !prevRenderContext.current) {\n      // ReactDOM.flushSync cannot be called on `scroll` events fired inside effects\n      if (isUIEvent(event)) {\n        // To prevent flickering, the inner position can only be updated after the new context has\n        // been rendered. ReactDOM.flushSync ensures that the state changes will happen before\n        // updating the position.\n        ReactDOM.flushSync(function () {\n          setRenderContext(nextRenderContext);\n        });\n        canUpdateInnerPosition = true;\n      } else {\n        setRenderContext(nextRenderContext);\n      }\n      prevRenderContext.current = nextRenderContext;\n    } else {\n      canUpdateInnerPosition = true;\n    } // Pass directly the render context to avoid waiting for the next render\n\n    if (nextRenderContext && canUpdateInnerPosition) {\n      updateInnerPosition(nextRenderContext);\n    }\n  }, [updateInnerPosition]);\n  var handleColumnResizeStart = React.useCallback(function (params) {\n    return setResizeCol(params.field);\n  }, []);\n  var handleColumnResizeStop = React.useCallback(function () {\n    return setResizeCol('');\n  }, []);\n  var handleColumnReorderStart = React.useCallback(function (params) {\n    return setDragCol(params.field);\n  }, []);\n  var handleColumnReorderStop = React.useCallback(function () {\n    return setDragCol('');\n  }, []);\n  useGridApiEventHandler(apiRef, 'columnResizeStart', handleColumnResizeStart);\n  useGridApiEventHandler(apiRef, 'columnResizeStop', handleColumnResizeStop);\n  useGridApiEventHandler(apiRef, 'columnHeaderDragStart', handleColumnReorderStart);\n  useGridApiEventHandler(apiRef, 'columnHeaderDragEnd', handleColumnReorderStop);\n  useGridApiEventHandler(apiRef, 'rowsScroll', handleScroll); // Helper for computation common between getColumnHeaders and getColumnGroupHeaders\n\n  var getColumnsToRender = function getColumnsToRender(params) {\n    var _ref2 = params || {},\n      _ref2$renderContext = _ref2.renderContext,\n      nextRenderContext = _ref2$renderContext === void 0 ? renderContext : _ref2$renderContext,\n      _ref2$minFirstColumn = _ref2.minFirstColumn,\n      minFirstColumn = _ref2$minFirstColumn === void 0 ? minColumnIndex : _ref2$minFirstColumn,\n      _ref2$maxLastColumn = _ref2.maxLastColumn,\n      maxLastColumn = _ref2$maxLastColumn === void 0 ? visibleColumns.length : _ref2$maxLastColumn;\n    if (!nextRenderContext) {\n      return null;\n    }\n    var _getRenderableIndexes3 = getRenderableIndexes({\n        firstIndex: nextRenderContext.firstRowIndex,\n        lastIndex: nextRenderContext.lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: currentPage.rows.length,\n        buffer: rootProps.rowBuffer\n      }),\n      _getRenderableIndexes4 = _slicedToArray(_getRenderableIndexes3, 2),\n      firstRowToRender = _getRenderableIndexes4[0],\n      lastRowToRender = _getRenderableIndexes4[1];\n    var firstColumnToRender = getFirstColumnIndexToRenderRef.current({\n      firstColumnIndex: nextRenderContext.firstColumnIndex,\n      minColumnIndex: minFirstColumn,\n      columnBuffer: rootProps.columnBuffer,\n      apiRef: apiRef,\n      firstRowToRender: firstRowToRender,\n      lastRowToRender: lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    var lastColumnToRender = Math.min(nextRenderContext.lastColumnIndex + rootProps.columnBuffer, maxLastColumn);\n    var renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    return {\n      renderedColumns: renderedColumns,\n      firstColumnToRender: firstColumnToRender,\n      lastColumnToRender: lastColumnToRender,\n      minFirstColumn: minFirstColumn,\n      maxLastColumn: maxLastColumn\n    };\n  };\n  var getColumnHeaders = function getColumnHeaders(params) {\n    var other = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var columnsToRender = getColumnsToRender(params);\n    if (columnsToRender == null) {\n      return null;\n    }\n    var renderedColumns = columnsToRender.renderedColumns,\n      firstColumnToRender = columnsToRender.firstColumnToRender;\n    var columns = [];\n    for (var i = 0; i < renderedColumns.length; i += 1) {\n      var column = renderedColumns[i];\n      var columnIndex = firstColumnToRender + i;\n      var isFirstColumn = columnIndex === 0;\n      var hasTabbableElement = !(tabIndexState === null && cellTabIndexState === null);\n      var tabIndex = tabIndexState !== null && tabIndexState.field === column.field || isFirstColumn && !hasTabbableElement ? 0 : -1;\n      var hasFocus = columnHeaderFocus !== null && columnHeaderFocus.field === column.field;\n      var open = columnMenuState.open && columnMenuState.field === column.field;\n      columns.push( /*#__PURE__*/_jsx(GridColumnHeaderItem, _extends({}, sortColumnLookup[column.field], {\n        columnMenuOpen: open,\n        filterItemsCounter: filterColumnLookup[column.field] && filterColumnLookup[column.field].length,\n        headerHeight: headerHeight,\n        isDragging: column.field === dragCol,\n        column: column,\n        colIndex: columnIndex,\n        isResizing: resizeCol === column.field,\n        isLastColumn: columnIndex === visibleColumns.length - 1,\n        extendRowFullWidth: !rootProps.disableExtendRowFullWidth,\n        hasFocus: hasFocus,\n        tabIndex: tabIndex\n      }, other), column.field));\n    }\n    return /*#__PURE__*/_jsx(GridColumnHeaderRow, {\n      role: \"row\",\n      \"aria-rowindex\": headerGroupingMaxDepth + 1,\n      children: columns\n    });\n  };\n  var getParents = function getParents() {\n    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var depth = arguments.length > 1 ? arguments[1] : undefined;\n    return path.slice(0, depth + 1);\n  };\n  var getColumnGroupHeaders = function getColumnGroupHeaders(params) {\n    if (headerGroupingMaxDepth === 0) {\n      return null;\n    }\n    var columnsToRender = getColumnsToRender(params);\n    if (columnsToRender == null) {\n      return null;\n    }\n    var renderedColumns = columnsToRender.renderedColumns,\n      firstColumnToRender = columnsToRender.firstColumnToRender,\n      lastColumnToRender = columnsToRender.lastColumnToRender,\n      maxLastColumn = columnsToRender.maxLastColumn;\n    var columns = [];\n    var headerToRender = [];\n    var _loop = function _loop(depth) {\n      // Initialize the header line with a grouping item containing all the columns on the left of the virtualization which are in the same group as the first group to render\n      var initialHeader = [];\n      var leftOverflow = 0;\n      var columnIndex = firstColumnToRender - 1;\n      var firstColumnToRenderGroup = (_visibleColumns$first = visibleColumns[firstColumnToRender]) == null ? void 0 : (_visibleColumns$first2 = _visibleColumns$first.groupPath) == null ? void 0 : _visibleColumns$first2[depth]; // The array of parent is used to manage empty grouping cell\n      // When two empty grouping cell are next to each other, we merge them if the belong to the same group.\n\n      var firstColumnToRenderGroupParents = getParents((_visibleColumns$first3 = visibleColumns[firstColumnToRender]) == null ? void 0 : _visibleColumns$first3.groupPath, depth);\n      while (firstColumnToRenderGroup !== null && columnIndex >= minColumnIndex && (_visibleColumns$colum = visibleColumns[columnIndex]) != null && _visibleColumns$colum.groupPath && isDeepEqual(getParents((_visibleColumns$colum2 = visibleColumns[columnIndex]) == null ? void 0 : _visibleColumns$colum2.groupPath, depth), firstColumnToRenderGroupParents)) {\n        var column = visibleColumns[columnIndex];\n        leftOverflow += (_column$computedWidth = column.computedWidth) != null ? _column$computedWidth : 0;\n        if (initialHeader.length === 0) {\n          initialHeader.push({\n            width: (_column$computedWidth2 = column.computedWidth) != null ? _column$computedWidth2 : 0,\n            fields: [column.field],\n            groupId: firstColumnToRenderGroup,\n            groupParents: firstColumnToRenderGroupParents,\n            colIndex: columnIndex\n          });\n        } else {\n          initialHeader[0].width += (_column$computedWidth3 = column.computedWidth) != null ? _column$computedWidth3 : 0;\n          initialHeader[0].fields.push(column.field);\n          initialHeader[0].colIndex = columnIndex;\n        }\n        columnIndex -= 1;\n      }\n      var depthInfo = renderedColumns.reduce(function (aggregated, column, i) {\n        var _column$computedWidth7;\n        var lastItem = aggregated[aggregated.length - 1];\n        if (column.groupPath && column.groupPath.length > depth) {\n          var _column$computedWidth5;\n          if (lastItem && lastItem.groupId === column.groupPath[depth]) {\n            var _column$computedWidth4;\n\n            // Merge with the previous columns\n            return [].concat(_toConsumableArray(aggregated.slice(0, aggregated.length - 1)), [_extends({}, lastItem, {\n              width: lastItem.width + ((_column$computedWidth4 = column.computedWidth) != null ? _column$computedWidth4 : 0),\n              fields: [].concat(_toConsumableArray(lastItem.fields), [column.field])\n            })]);\n          } // Create a new grouping\n\n          return [].concat(_toConsumableArray(aggregated), [{\n            groupId: column.groupPath[depth],\n            groupParents: getParents(column.groupPath, depth),\n            width: (_column$computedWidth5 = column.computedWidth) != null ? _column$computedWidth5 : 0,\n            fields: [column.field],\n            colIndex: firstColumnToRender + i\n          }]);\n        }\n        if (MERGE_EMPTY_CELLS && lastItem && lastItem.groupId === null && isDeepEqual(getParents(column.groupPath, depth), lastItem.groupParents)) {\n          var _column$computedWidth6;\n\n          // We merge with previous column\n          return [].concat(_toConsumableArray(aggregated.slice(0, aggregated.length - 1)), [_extends({}, lastItem, {\n            width: lastItem.width + ((_column$computedWidth6 = column.computedWidth) != null ? _column$computedWidth6 : 0),\n            fields: [].concat(_toConsumableArray(lastItem.fields), [column.field])\n          })]);\n        } // We create new empty cell\n\n        return [].concat(_toConsumableArray(aggregated), [{\n          groupId: null,\n          groupParents: getParents(column.groupPath, depth),\n          width: (_column$computedWidth7 = column.computedWidth) != null ? _column$computedWidth7 : 0,\n          fields: [column.field],\n          colIndex: firstColumnToRender + i\n        }]);\n      }, initialHeader);\n      columnIndex = lastColumnToRender;\n      var lastColumnToRenderGroup = depthInfo[depthInfo.length - 1].groupId;\n      while (lastColumnToRenderGroup !== null && columnIndex < maxLastColumn && (_visibleColumns$colum3 = visibleColumns[columnIndex]) != null && _visibleColumns$colum3.groupPath && ((_visibleColumns$colum4 = visibleColumns[columnIndex]) == null ? void 0 : (_visibleColumns$colum5 = _visibleColumns$colum4.groupPath) == null ? void 0 : _visibleColumns$colum5[depth]) === lastColumnToRenderGroup) {\n        var _column = visibleColumns[columnIndex];\n        depthInfo[depthInfo.length - 1].width += (_column$computedWidth8 = _column.computedWidth) != null ? _column$computedWidth8 : 0;\n        depthInfo[depthInfo.length - 1].fields.push(_column.field);\n        columnIndex += 1;\n      }\n      headerToRender.push({\n        leftOverflow: leftOverflow,\n        elements: _toConsumableArray(depthInfo)\n      });\n    };\n    for (var depth = 0; depth < headerGroupingMaxDepth; depth += 1) {\n      var _visibleColumns$first, _visibleColumns$first2, _visibleColumns$first3;\n      var _visibleColumns$colum, _visibleColumns$colum2, _column$computedWidth;\n      var _column$computedWidth2;\n      var _column$computedWidth3;\n      var _visibleColumns$colum3, _visibleColumns$colum4, _visibleColumns$colum5, _column$computedWidth8;\n      _loop(depth);\n    }\n    headerToRender.forEach(function (depthInfo, depthIndex) {\n      columns.push( /*#__PURE__*/_jsx(GridColumnHeaderRow, {\n        style: {\n          height: \"\".concat(headerHeight, \"px\"),\n          transform: \"translateX(-\".concat(depthInfo.leftOverflow, \"px)\")\n        },\n        role: \"row\",\n        \"aria-rowindex\": depthIndex + 1,\n        children: depthInfo.elements.map(function (_ref3, groupIndex) {\n          var groupId = _ref3.groupId,\n            width = _ref3.width,\n            fields = _ref3.fields,\n            colIndex = _ref3.colIndex;\n          return /*#__PURE__*/_jsx(GridColumnGroupHeader, {\n            groupId: groupId,\n            width: width,\n            fields: fields,\n            colIndex: colIndex,\n            depth: depthIndex,\n            isLastColumn: colIndex === visibleColumns.length - fields.length,\n            extendRowFullWidth: !rootProps.disableExtendRowFullWidth,\n            maxDepth: headerToRender.length,\n            height: headerHeight\n          }, groupIndex);\n        })\n      }, depthIndex));\n    });\n    return columns;\n  };\n  var rootStyle = {\n    minHeight: totalHeaderHeight,\n    maxHeight: totalHeaderHeight,\n    lineHeight: \"\".concat(headerHeight, \"px\")\n  };\n  return {\n    renderContext: renderContext,\n    getColumnHeaders: getColumnHeaders,\n    getColumnGroupHeaders: getColumnGroupHeaders,\n    isDragging: !!dragCol,\n    getRootProps: function getRootProps() {\n      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return _extends({\n        style: rootStyle\n      }, other);\n    },\n    getInnerProps: function getInnerProps() {\n      return {\n        ref: handleInnerRef,\n        role: 'rowgroup'\n      };\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module"}