{"ast":null,"code":"import _slicedToArray from \"/Users/mac/Desktop/phase_4_client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nvar _excluded = [\"style\"];\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { useForkRef } from '@mui/material/utils';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridDensityRowHeightSelector } from '../density/densitySelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { gridEditRowsStateSelector } from '../editRows/gridEditRowsSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { clamp } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../selection/gridSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils'; // Uses binary search to avoid looping through all possible positions\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function binarySearch(offset, positions) {\n  var sliceStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var sliceEnd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : positions.length;\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  var pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  var itemOffset = positions[pivot];\n  return offset <= itemOffset ? binarySearch(offset, positions, sliceStart, pivot) : binarySearch(offset, positions, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index) {\n  var interval = 1;\n  while (index < positions.length && positions[index] < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, Math.floor(index / 2), Math.min(index, positions.length));\n}\nexport var getRenderableIndexes = function getRenderableIndexes(_ref2) {\n  var firstIndex = _ref2.firstIndex,\n    lastIndex = _ref2.lastIndex,\n    buffer = _ref2.buffer,\n    minFirstIndex = _ref2.minFirstIndex,\n    maxLastIndex = _ref2.maxLastIndex;\n  return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];\n};\nexport var useGridVirtualScroller = function useGridVirtualScroller(props) {\n  var _currentPage$range3, _currentPage$range4;\n  var apiRef = useGridApiContext();\n  var rootProps = useGridRootProps();\n  var visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  var ref = props.ref,\n    disableVirtualization = props.disableVirtualization,\n    onRenderZonePositioning = props.onRenderZonePositioning,\n    _props$renderZoneMinC = props.renderZoneMinColumnIndex,\n    renderZoneMinColumnIndex = _props$renderZoneMinC === void 0 ? 0 : _props$renderZoneMinC,\n    _props$renderZoneMaxC = props.renderZoneMaxColumnIndex,\n    renderZoneMaxColumnIndex = _props$renderZoneMaxC === void 0 ? visibleColumns.length : _props$renderZoneMaxC,\n    getRowProps = props.getRowProps;\n  var columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  var columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  var rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);\n  var cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  var cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  var rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  var editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);\n  var selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  var currentPage = useGridVisibleRows(apiRef, rootProps);\n  var renderZoneRef = React.useRef(null);\n  var rootRef = React.useRef(null);\n  var handleRef = useForkRef(ref, rootRef);\n  var _React$useState = React.useState(null),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    renderContext = _React$useState2[0],\n    setRenderContext = _React$useState2[1];\n  var prevRenderContext = React.useRef(renderContext);\n  var scrollPosition = React.useRef({\n    top: 0,\n    left: 0\n  });\n  var _React$useState3 = React.useState(null),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    containerWidth = _React$useState4[0],\n    setContainerWidth = _React$useState4[1];\n  var prevTotalWidth = React.useRef(columnsTotalWidth);\n  var getNearestIndexToRender = React.useCallback(function (offset) {\n    var _currentPage$range, _currentPage$range2;\n    var lastMeasuredIndexRelativeToAllRows = apiRef.current.unstable_getLastMeasuredRowIndex();\n    var lastMeasuredIndexRelativeToCurrentPage = lastMeasuredIndexRelativeToAllRows - (((_currentPage$range = currentPage.range) == null ? void 0 : _currentPage$range.firstRowIndex) || 0);\n    var lastMeasuredIndex = Math.max(0, lastMeasuredIndexRelativeToCurrentPage);\n    var allRowsMeasured = lastMeasuredIndex === Infinity;\n    if ((_currentPage$range2 = currentPage.range) != null && _currentPage$range2.lastRowIndex && !allRowsMeasured) {\n      // Check if all rows in this page are already measured\n      allRowsMeasured = lastMeasuredIndex >= currentPage.range.lastRowIndex;\n    }\n    if (allRowsMeasured || rowsMeta.positions[lastMeasuredIndex] >= offset) {\n      // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n      // were measured, then use a binary search because it's faster.\n      return binarySearch(offset, rowsMeta.positions);\n    } // Otherwise, use an exponential search.\n    // If rows have \"auto\" as height, their positions will be based on estimated heights.\n    // In this case, we can skip several steps until we find a position higher than the offset.\n    // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n\n    return exponentialSearch(offset, rowsMeta.positions, lastMeasuredIndex);\n  }, [apiRef, (_currentPage$range3 = currentPage.range) == null ? void 0 : _currentPage$range3.firstRowIndex, (_currentPage$range4 = currentPage.range) == null ? void 0 : _currentPage$range4.lastRowIndex, rowsMeta.positions]);\n  var computeRenderContext = React.useCallback(function () {\n    if (disableVirtualization) {\n      return {\n        firstRowIndex: 0,\n        lastRowIndex: currentPage.rows.length,\n        firstColumnIndex: 0,\n        lastColumnIndex: visibleColumns.length\n      };\n    }\n    var _scrollPosition$curre = scrollPosition.current,\n      top = _scrollPosition$curre.top,\n      left = _scrollPosition$curre.left; // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    var firstRowIndex = Math.min(getNearestIndexToRender(top), rowsMeta.positions.length - 1);\n    var lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getNearestIndexToRender(top + rootRef.current.clientHeight);\n    var hasRowWithAutoHeight = false;\n    var firstColumnIndex = 0;\n    var lastColumnIndex = columnPositions.length;\n    var _getRenderableIndexes = getRenderableIndexes({\n        firstIndex: firstRowIndex,\n        lastIndex: lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: currentPage.rows.length,\n        buffer: rootProps.rowBuffer\n      }),\n      _getRenderableIndexes2 = _slicedToArray(_getRenderableIndexes, 2),\n      firstRowToRender = _getRenderableIndexes2[0],\n      lastRowToRender = _getRenderableIndexes2[1];\n    for (var i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n      var row = currentPage.rows[i];\n      hasRowWithAutoHeight = apiRef.current.unstable_rowHasAutoHeight(row.id);\n    }\n    if (!hasRowWithAutoHeight) {\n      firstColumnIndex = binarySearch(left, columnPositions);\n      lastColumnIndex = binarySearch(left + containerWidth, columnPositions);\n    }\n    return {\n      firstRowIndex: firstRowIndex,\n      lastRowIndex: lastRowIndex,\n      firstColumnIndex: firstColumnIndex,\n      lastColumnIndex: lastColumnIndex\n    };\n  }, [disableVirtualization, getNearestIndexToRender, rowsMeta.positions.length, rootProps.autoHeight, rootProps.rowBuffer, currentPage.rows, columnPositions, visibleColumns.length, apiRef, containerWidth]);\n  React.useEffect(function () {\n    if (disableVirtualization) {\n      renderZoneRef.current.style.transform = \"translate3d(0px, 0px, 0px)\";\n    } else {\n      // TODO a scroll reset should not be necessary\n      rootRef.current.scrollLeft = 0;\n      rootRef.current.scrollTop = 0;\n    }\n  }, [disableVirtualization]);\n  React.useEffect(function () {\n    setContainerWidth(rootRef.current.clientWidth);\n  }, [rowsMeta.currentPageTotalHeight]);\n  var handleResize = React.useCallback(function (params) {\n    setContainerWidth(params.width);\n  }, []);\n  useGridApiEventHandler(apiRef, 'resize', handleResize);\n  var updateRenderZonePosition = React.useCallback(function (nextRenderContext) {\n    var _getRenderableIndexes3 = getRenderableIndexes({\n        firstIndex: nextRenderContext.firstRowIndex,\n        lastIndex: nextRenderContext.lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: currentPage.rows.length,\n        buffer: rootProps.rowBuffer\n      }),\n      _getRenderableIndexes4 = _slicedToArray(_getRenderableIndexes3, 2),\n      firstRowToRender = _getRenderableIndexes4[0],\n      lastRowToRender = _getRenderableIndexes4[1];\n    var _getRenderableIndexes5 = getRenderableIndexes({\n        firstIndex: nextRenderContext.firstColumnIndex,\n        lastIndex: nextRenderContext.lastColumnIndex,\n        minFirstIndex: renderZoneMinColumnIndex,\n        maxLastIndex: renderZoneMaxColumnIndex,\n        buffer: rootProps.columnBuffer\n      }),\n      _getRenderableIndexes6 = _slicedToArray(_getRenderableIndexes5, 1),\n      initialFirstColumnToRender = _getRenderableIndexes6[0];\n    var firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef: apiRef,\n      firstRowToRender: firstRowToRender,\n      lastRowToRender: lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    var top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];\n    var left = gridColumnPositionsSelector(apiRef)[firstColumnToRender]; // Call directly the selector because it might be outdated when this method is called\n\n    renderZoneRef.current.style.transform = \"translate3d(\".concat(left, \"px, \").concat(top, \"px, 0px)\");\n    if (typeof onRenderZonePositioning === 'function') {\n      onRenderZonePositioning({\n        top: top,\n        left: left\n      });\n    }\n  }, [apiRef, currentPage.rows, onRenderZonePositioning, renderZoneMinColumnIndex, renderZoneMaxColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);\n  React.useLayoutEffect(function () {\n    if (renderContext) {\n      updateRenderZonePosition(renderContext);\n    }\n  }, [renderContext, updateRenderZonePosition]);\n  var updateRenderContext = React.useCallback(function (nextRenderContext) {\n    setRenderContext(nextRenderContext);\n    var _getRenderableIndexes7 = getRenderableIndexes({\n        firstIndex: nextRenderContext.firstRowIndex,\n        lastIndex: nextRenderContext.lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: currentPage.rows.length,\n        buffer: rootProps.rowBuffer\n      }),\n      _getRenderableIndexes8 = _slicedToArray(_getRenderableIndexes7, 2),\n      firstRowToRender = _getRenderableIndexes8[0],\n      lastRowToRender = _getRenderableIndexes8[1];\n    apiRef.current.publishEvent('renderedRowsIntervalChange', {\n      firstRowToRender: firstRowToRender,\n      lastRowToRender: lastRowToRender\n    });\n    prevRenderContext.current = nextRenderContext;\n  }, [apiRef, setRenderContext, prevRenderContext, currentPage.rows.length, rootProps.rowBuffer]);\n  React.useEffect(function () {\n    if (containerWidth == null) {\n      return;\n    }\n    var initialRenderContext = computeRenderContext();\n    updateRenderContext(initialRenderContext);\n    var _scrollPosition$curre2 = scrollPosition.current,\n      top = _scrollPosition$curre2.top,\n      left = _scrollPosition$curre2.left;\n    var params = {\n      top: top,\n      left: left,\n      renderContext: initialRenderContext\n    };\n    apiRef.current.publishEvent('rowsScroll', params);\n  }, [apiRef, computeRenderContext, containerWidth, updateRenderContext]);\n  var handleScroll = function handleScroll(event) {\n    var _event$currentTarget = event.currentTarget,\n      scrollTop = _event$currentTarget.scrollTop,\n      scrollLeft = _event$currentTarget.scrollLeft;\n    scrollPosition.current.top = scrollTop;\n    scrollPosition.current.left = scrollLeft; // On iOS and macOS, negative offsets are possible when swiping past the start\n\n    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {\n      return;\n    } // When virtualization is disabled, the context never changes during scroll\n\n    var nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();\n    var topRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);\n    var bottomRowsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastRowIndex - prevRenderContext.current.lastRowIndex);\n    var topColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);\n    var bottomColumnsScrolledSincePreviousRender = Math.abs(nextRenderContext.lastColumnIndex - prevRenderContext.current.lastColumnIndex);\n    var shouldSetState = topRowsScrolledSincePreviousRender >= rootProps.rowThreshold || bottomRowsScrolledSincePreviousRender >= rootProps.rowThreshold || topColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || bottomColumnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth; // TODO v6: rename event to a wider name, it's not only fired for row scrolling\n\n    apiRef.current.publishEvent('rowsScroll', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current\n    }, event);\n    if (shouldSetState) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(function () {\n        updateRenderContext(nextRenderContext);\n      });\n      prevTotalWidth.current = columnsTotalWidth;\n    }\n  };\n  var handleWheel = function handleWheel(event) {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  };\n  var handleTouchMove = function handleTouchMove(event) {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  };\n  var getRows = function getRows() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      renderContext: renderContext\n    };\n    var nextRenderContext = params.renderContext,\n      _params$minFirstColum = params.minFirstColumn,\n      minFirstColumn = _params$minFirstColum === void 0 ? renderZoneMinColumnIndex : _params$minFirstColum,\n      _params$maxLastColumn = params.maxLastColumn,\n      maxLastColumn = _params$maxLastColumn === void 0 ? renderZoneMaxColumnIndex : _params$maxLastColumn,\n      _params$availableSpac = params.availableSpace,\n      availableSpace = _params$availableSpac === void 0 ? containerWidth : _params$availableSpac,\n      _params$rowIndexOffse = params.rowIndexOffset,\n      rowIndexOffset = _params$rowIndexOffse === void 0 ? 0 : _params$rowIndexOffse,\n      _params$position = params.position,\n      position = _params$position === void 0 ? 'center' : _params$position;\n    if (!nextRenderContext || availableSpace == null) {\n      return null;\n    }\n    var rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;\n    var columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;\n    var _getRenderableIndexes9 = getRenderableIndexes({\n        firstIndex: nextRenderContext.firstRowIndex,\n        lastIndex: nextRenderContext.lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: currentPage.rows.length,\n        buffer: rowBuffer\n      }),\n      _getRenderableIndexes10 = _slicedToArray(_getRenderableIndexes9, 2),\n      firstRowToRender = _getRenderableIndexes10[0],\n      lastRowToRender = _getRenderableIndexes10[1];\n    var renderedRows = [];\n    if (params.rows) {\n      params.rows.forEach(function (row) {\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn: minFirstColumn,\n          maxLastColumn: maxLastColumn,\n          columns: visibleColumns\n        });\n      });\n    } else {\n      if (!currentPage.range) {\n        return null;\n      }\n      for (var i = firstRowToRender; i < lastRowToRender; i += 1) {\n        var row = currentPage.rows[i];\n        renderedRows.push(row);\n        apiRef.current.unstable_calculateColSpan({\n          rowId: row.id,\n          minFirstColumn: minFirstColumn,\n          maxLastColumn: maxLastColumn,\n          columns: visibleColumns\n        });\n      }\n    }\n    var _getRenderableIndexes11 = getRenderableIndexes({\n        firstIndex: nextRenderContext.firstColumnIndex,\n        lastIndex: nextRenderContext.lastColumnIndex,\n        minFirstIndex: minFirstColumn,\n        maxLastIndex: maxLastColumn,\n        buffer: columnBuffer\n      }),\n      _getRenderableIndexes12 = _slicedToArray(_getRenderableIndexes11, 2),\n      initialFirstColumnToRender = _getRenderableIndexes12[0],\n      lastColumnToRender = _getRenderableIndexes12[1];\n    var firstColumnToRender = getFirstNonSpannedColumnToRender({\n      firstColumnToRender: initialFirstColumnToRender,\n      apiRef: apiRef,\n      firstRowToRender: firstRowToRender,\n      lastRowToRender: lastRowToRender,\n      visibleRows: currentPage.rows\n    });\n    var renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n    var rows = [];\n    for (var _i = 0; _i < renderedRows.length; _i += 1) {\n      var _currentPage$range5, _rootProps$components;\n      var _renderedRows$_i = renderedRows[_i],\n        id = _renderedRows$_i.id,\n        model = _renderedRows$_i.model;\n      var lastVisibleRowIndex = firstRowToRender + _i === currentPage.rows.length - 1;\n      var baseRowHeight = !apiRef.current.unstable_rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      var isSelected = void 0;\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n      rows.push( /*#__PURE__*/_jsx(rootProps.components.Row, _extends({\n        row: model,\n        rowId: id,\n        rowHeight: baseRowHeight,\n        cellFocus: cellFocus // TODO move to inside the row\n        ,\n\n        cellTabIndex: cellTabIndex // TODO move to inside the row\n        ,\n\n        editRowsState: editRowsState // TODO move to inside the row\n        ,\n\n        renderedColumns: renderedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnToRender: firstColumnToRender,\n        lastColumnToRender: lastColumnToRender,\n        selected: isSelected,\n        index: rowIndexOffset + ((currentPage == null ? void 0 : (_currentPage$range5 = currentPage.range) == null ? void 0 : _currentPage$range5.firstRowIndex) || 0) + firstRowToRender + _i,\n        containerWidth: availableSpace,\n        isLastVisible: lastVisibleRowIndex,\n        position: position\n      }, typeof getRowProps === 'function' ? getRowProps(id, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id));\n    }\n    return rows;\n  };\n  var needsHorizontalScrollbar = containerWidth && columnsTotalWidth > containerWidth;\n  var contentSize = React.useMemo(function () {\n    // In cases where the columns exceed the available width,\n    // the horizontal scrollbar should be shown even when there're no rows.\n    // Keeping 1px as minimum height ensures that the scrollbar will visible if necessary.\n    var height = Math.max(rowsMeta.currentPageTotalHeight, 1);\n    var shouldExtendContent = false;\n    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {\n      shouldExtendContent = true;\n    }\n    var size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height: height,\n      minHeight: shouldExtendContent ? '100%' : 'auto'\n    };\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = 2 * rowHeight; // Give room to show the overlay when there's no row.\n    }\n\n    return size;\n  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);\n  React.useEffect(function () {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  if (rootProps.autoHeight && currentPage.rows.length === 0) {\n    contentSize.height = 2 * rowHeight; // Give room to show the overlay when there no rows.\n  }\n\n  var rootStyle = {};\n  if (!needsHorizontalScrollbar) {\n    rootStyle.overflowX = 'hidden';\n  }\n  if (rootProps.autoHeight) {\n    rootStyle.overflowY = 'hidden';\n  }\n  var getRenderContext = React.useCallback(function () {\n    return prevRenderContext.current;\n  }, []);\n  apiRef.current.unstable_getRenderContext = getRenderContext;\n  return {\n    renderContext: renderContext,\n    updateRenderZonePosition: updateRenderZonePosition,\n    getRows: getRows,\n    getRootProps: function getRootProps() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _ref$style = _ref.style,\n        style = _ref$style === void 0 ? {} : _ref$style,\n        other = _objectWithoutPropertiesLoose(_ref, _excluded);\n      return _extends({\n        ref: handleRef,\n        onScroll: handleScroll,\n        onWheel: handleWheel,\n        onTouchMove: handleTouchMove,\n        style: _extends({}, style, rootStyle)\n      }, other);\n    },\n    getContentProps: function getContentProps() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$style = _ref3.style,\n        style = _ref3$style === void 0 ? {} : _ref3$style;\n      return {\n        style: _extends({}, style, contentSize)\n      };\n    },\n    getRenderZoneProps: function getRenderZoneProps() {\n      return {\n        ref: renderZoneRef\n      };\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module"}