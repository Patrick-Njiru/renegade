{"ast":null,"code":"import _defineProperty from \"/Users/mac/Desktop/phase_4_client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/mac/Desktop/phase_4_client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nvar _excluded = [\"groupId\", \"children\"];\nimport * as React from 'react';\nimport { isLeaf } from '../../../models/gridColumnGrouping';\nimport { gridColumnGroupsLookupSelector } from './gridColumnGroupsSelector';\nimport { gridColumnLookupSelector } from '../columns/gridColumnsSelector';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nexport function hasGroupPath(lookupElement) {\n  return lookupElement.groupPath !== undefined;\n}\n\n// This is the recurrence function that help writing `unwrapGroupingColumnModel()`\nvar recurrentUnwrapGroupingColumnModel = function recurrentUnwrapGroupingColumnModel(columnGroupNode, parents, unwrappedGroupingModelToComplet) {\n  if (isLeaf(columnGroupNode)) {\n    if (unwrappedGroupingModelToComplet[columnGroupNode.field] !== undefined) {\n      throw new Error([\"MUI: columnGroupingModel contains duplicated field\", \"column field \".concat(columnGroupNode.field, \" occurrs two times in the grouping model:\"), \"- \".concat(unwrappedGroupingModelToComplet[columnGroupNode.field].join(' > ')), \"- \".concat(parents.join(' > '))].join('\\n'));\n    }\n    unwrappedGroupingModelToComplet[columnGroupNode.field] = parents;\n    return;\n  }\n  var groupId = columnGroupNode.groupId,\n    children = columnGroupNode.children;\n  children.forEach(function (child) {\n    recurrentUnwrapGroupingColumnModel(child, [].concat(_toConsumableArray(parents), [groupId]), unwrappedGroupingModelToComplet);\n  });\n};\n/**\n * This is a function that provide for each column the array of its parents.\n * Parents are ordered from the root to the leaf.\n * @param columnGroupingModel The model such as provided in DataGrid props\n * @returns An object `{[field]: groupIds}` where `groupIds` is the parents of the column `field`\n */\n\nexport var unwrapGroupingColumnModel = function unwrapGroupingColumnModel(columnGroupingModel) {\n  if (!columnGroupingModel) {\n    return {};\n  }\n  var unwrappedSubTree = {};\n  columnGroupingModel.forEach(function (columnGroupNode) {\n    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);\n  });\n  return unwrappedSubTree;\n};\nvar createGroupLookup = function createGroupLookup(columnGroupingModel) {\n  var groupLookup = {};\n  columnGroupingModel.forEach(function (node) {\n    if (isLeaf(node)) {\n      return;\n    }\n    var groupId = node.groupId,\n      children = node.children,\n      other = _objectWithoutPropertiesLoose(node, _excluded);\n    if (!groupId) {\n      throw new Error('MUI: An element of the columnGroupingModel does not have either `field` or `groupId`.');\n    }\n    if (!children) {\n      console.warn(\"MUI: group groupId=\".concat(groupId, \" has no children.\"));\n    }\n    var groupParam = _extends({}, other, {\n      groupId: groupId\n    });\n    var subTreeLookup = createGroupLookup(children);\n    if (subTreeLookup[groupId] !== undefined || groupLookup[groupId] !== undefined) {\n      throw new Error(\"MUI: The groupId \".concat(groupId, \" is used multiple times in the columnGroupingModel.\"));\n    }\n    groupLookup = _extends({}, groupLookup, subTreeLookup, _defineProperty({}, groupId, groupParam));\n  });\n  return _extends({}, groupLookup);\n};\nexport var columnGroupsStateInitializer = function columnGroupsStateInitializer(state, props) {\n  var _props$columnGrouping;\n  var groupLookup = createGroupLookup((_props$columnGrouping = props.columnGroupingModel) != null ? _props$columnGrouping : []);\n  return _extends({}, state, {\n    columnGrouping: {\n      lookup: groupLookup,\n      groupCollapsedModel: {}\n    }\n  });\n};\n/**\n * @requires useGridColumns (method, event)\n * @requires useGridParamsApi (method)\n */\n\nexport var useGridColumnGrouping = function useGridColumnGrouping(apiRef, props) {\n  var _props$experimentalFe2;\n\n  /**\n   * API METHODS\n   */\n  var getColumnGroupPath = React.useCallback(function (field) {\n    var _columnLookup$field$g, _columnLookup$field;\n    var columnLookup = gridColumnLookupSelector(apiRef);\n    return (_columnLookup$field$g = (_columnLookup$field = columnLookup[field]) == null ? void 0 : _columnLookup$field.groupPath) != null ? _columnLookup$field$g : [];\n  }, [apiRef]);\n  var getAllGroupDetails = React.useCallback(function () {\n    var columnGroupLookup = gridColumnGroupsLookupSelector(apiRef);\n    return columnGroupLookup;\n  }, [apiRef]);\n  var columnGroupingApi = {\n    unstable_getColumnGroupPath: getColumnGroupPath,\n    unstable_getAllGroupDetails: getAllGroupDetails\n  };\n  useGridApiMethod(apiRef, columnGroupingApi, 'GridColumnGroupingApi');\n  /**\n   * EFFECTS\n   */\n  // The effect does not track any value defined synchronously during the 1st render by hooks called after `useGridColumns`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  var isFirstRender = React.useRef(true);\n  React.useEffect(function () {\n    var _props$experimentalFe, _props$columnGrouping2;\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n    if (!((_props$experimentalFe = props.experimentalFeatures) != null && _props$experimentalFe.columnGrouping)) {\n      return;\n    }\n    var groupLookup = createGroupLookup((_props$columnGrouping2 = props.columnGroupingModel) != null ? _props$columnGrouping2 : []);\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        columnGrouping: _extends({}, state.columnGrouping, {\n          lookup: groupLookup\n        })\n      });\n    });\n  }, [apiRef, props.columnGroupingModel, (_props$experimentalFe2 = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe2.columnGrouping]);\n};","map":null,"metadata":{},"sourceType":"module"}