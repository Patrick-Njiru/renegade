{"ast":null,"code":"import _toConsumableArray from \"/Users/mac/Desktop/phase_4_client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { gridVisibleColumnDefinitionsSelector } from '../columns/gridColumnsSelector';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { gridVisibleSortedRowEntriesSelector } from '../filter/gridFilterSelector';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { GRID_CHECKBOX_SELECTION_COL_DEF } from '../../../colDef/gridCheckboxSelectionColDef';\nimport { gridClasses } from '../../../constants/gridClasses';\nimport { GridCellModes } from '../../../models/gridEditRowModel';\nimport { isNavigationKey } from '../../../utils/keyboardUtils';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from '../../../constants/gridDetailPanelToggleField';\nimport { gridPinnedRowsSelector } from '../rows/gridRowsSelector';\nfunction enrichPageRowsWithPinnedRows(apiRef, rows) {\n  var pinnedRows = gridPinnedRowsSelector(apiRef) || {};\n  return [].concat(_toConsumableArray(pinnedRows.top || []), _toConsumableArray(rows), _toConsumableArray(pinnedRows.bottom || []));\n}\n/**\n * @requires useGridSorting (method) - can be after\n * @requires useGridFilter (state) - can be after\n * @requires useGridColumns (state, method) - can be after\n * @requires useGridDimensions (method) - can be after\n * @requires useGridFocus (method) - can be after\n * @requires useGridScroll (method) - can be after\n * @requires useGridColumnSpanning (method) - can be after\n */\n\nexport var useGridKeyboardNavigation = function useGridKeyboardNavigation(apiRef, props) {\n  var logger = useGridLogger(apiRef, 'useGridKeyboardNavigation');\n  var initialCurrentPageRows = useGridVisibleRows(apiRef, props).rows;\n  var currentPageRows = React.useMemo(function () {\n    return enrichPageRowsWithPinnedRows(apiRef, initialCurrentPageRows);\n  }, [apiRef, initialCurrentPageRows]);\n  /**\n   * @param {number} colIndex Index of the column to focus\n   * @param {number} rowIndex index of the row to focus\n   * @param {string} closestColumnToUse Which closest column cell to use when the cell is spanned by `colSpan`.\n   * TODO replace with apiRef.current.unstable_moveFocusToRelativeCell()\n   */\n\n  var goToCell = React.useCallback(function (colIndex, rowId) {\n    var closestColumnToUse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'left';\n    var visibleSortedRows = gridVisibleSortedRowEntriesSelector(apiRef);\n    var nextCellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, colIndex);\n    if (nextCellColSpanInfo && nextCellColSpanInfo.spannedByColSpan) {\n      if (closestColumnToUse === 'left') {\n        colIndex = nextCellColSpanInfo.leftVisibleCellIndex;\n      } else if (closestColumnToUse === 'right') {\n        colIndex = nextCellColSpanInfo.rightVisibleCellIndex;\n      }\n    } // `scrollToIndexes` requires a rowIndex relative to all visible rows.\n    // Those rows do not include pinned rows, but pinned rows do not need scroll anyway.\n\n    var rowIndexRelativeToAllRows = visibleSortedRows.findIndex(function (row) {\n      return row.id === rowId;\n    });\n    logger.debug(\"Navigating to cell row \".concat(rowIndexRelativeToAllRows, \", col \").concat(colIndex));\n    apiRef.current.scrollToIndexes({\n      colIndex: colIndex,\n      rowIndex: rowIndexRelativeToAllRows\n    });\n    var field = apiRef.current.getVisibleColumns()[colIndex].field;\n    apiRef.current.setCellFocus(rowId, field);\n  }, [apiRef, logger]);\n  var goToHeader = React.useCallback(function (colIndex, event) {\n    logger.debug(\"Navigating to header col \".concat(colIndex));\n    apiRef.current.scrollToIndexes({\n      colIndex: colIndex\n    });\n    var field = apiRef.current.getVisibleColumns()[colIndex].field;\n    apiRef.current.setColumnHeaderFocus(field, event);\n  }, [apiRef, logger]);\n  var getRowIdFromIndex = React.useCallback(function (rowIndex) {\n    return currentPageRows[rowIndex].id;\n  }, [currentPageRows]);\n  var handleCellNavigationKeyDown = React.useCallback(function (params, event) {\n    var dimensions = apiRef.current.getRootDimensions();\n    if (currentPageRows.length === 0 || !dimensions) {\n      return;\n    }\n    var viewportPageSize = apiRef.current.unstable_getViewportPageSize();\n    var colIndexBefore = params.field ? apiRef.current.getColumnIndex(params.field) : 0;\n    var rowIndexBefore = currentPageRows.findIndex(function (row) {\n      return row.id === params.id;\n    });\n    var firstRowIndexInPage = 0;\n    var lastRowIndexInPage = currentPageRows.length - 1;\n    var firstColIndex = 0;\n    var lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;\n    var shouldPreventDefault = true;\n    switch (event.key) {\n      case 'ArrowDown':\n      case 'Enter':\n        {\n          // TODO v6: Remove Enter case because `cellNavigationKeyDown` is not fired by the new editing API\n          // \"Enter\" is only triggered by the row / cell editing feature\n          if (rowIndexBefore < lastRowIndexInPage) {\n            goToCell(colIndexBefore, getRowIdFromIndex(rowIndexBefore + 1));\n          }\n          break;\n        }\n      case 'ArrowUp':\n        {\n          if (rowIndexBefore > firstRowIndexInPage) {\n            goToCell(colIndexBefore, getRowIdFromIndex(rowIndexBefore - 1));\n          } else {\n            goToHeader(colIndexBefore, event);\n          }\n          break;\n        }\n      case 'ArrowRight':\n        {\n          if (colIndexBefore < lastColIndex) {\n            goToCell(colIndexBefore + 1, getRowIdFromIndex(rowIndexBefore), 'right');\n          }\n          break;\n        }\n      case 'ArrowLeft':\n        {\n          if (colIndexBefore > firstColIndex) {\n            goToCell(colIndexBefore - 1, getRowIdFromIndex(rowIndexBefore));\n          }\n          break;\n        }\n      case 'Tab':\n        {\n          // \"Tab\" is only triggered by the row / cell editing feature\n          if (event.shiftKey && colIndexBefore > firstColIndex) {\n            goToCell(colIndexBefore - 1, getRowIdFromIndex(rowIndexBefore), 'left');\n          } else if (!event.shiftKey && colIndexBefore < lastColIndex) {\n            goToCell(colIndexBefore + 1, getRowIdFromIndex(rowIndexBefore), 'right');\n          }\n          break;\n        }\n      case ' ':\n        {\n          var field = params.field;\n          if (field === GRID_DETAIL_PANEL_TOGGLE_FIELD) {\n            break;\n          }\n          var colDef = params.colDef;\n          if (colDef && colDef.type === 'treeDataGroup') {\n            break;\n          }\n          if (!event.shiftKey && rowIndexBefore < lastRowIndexInPage) {\n            goToCell(colIndexBefore, getRowIdFromIndex(Math.min(rowIndexBefore + viewportPageSize, lastRowIndexInPage)));\n          }\n          break;\n        }\n      case 'PageDown':\n        {\n          if (rowIndexBefore < lastRowIndexInPage) {\n            goToCell(colIndexBefore, getRowIdFromIndex(Math.min(rowIndexBefore + viewportPageSize, lastRowIndexInPage)));\n          }\n          break;\n        }\n      case 'PageUp':\n        {\n          // Go to the first row before going to header\n          var nextRowIndex = Math.max(rowIndexBefore - viewportPageSize, firstRowIndexInPage);\n          if (nextRowIndex !== rowIndexBefore && nextRowIndex >= firstRowIndexInPage) {\n            goToCell(colIndexBefore, getRowIdFromIndex(nextRowIndex));\n          } else {\n            goToHeader(colIndexBefore, event);\n          }\n          break;\n        }\n      case 'Home':\n        {\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            goToCell(firstColIndex, getRowIdFromIndex(firstRowIndexInPage));\n          } else {\n            goToCell(firstColIndex, getRowIdFromIndex(rowIndexBefore));\n          }\n          break;\n        }\n      case 'End':\n        {\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            goToCell(lastColIndex, getRowIdFromIndex(lastRowIndexInPage));\n          } else {\n            goToCell(lastColIndex, getRowIdFromIndex(rowIndexBefore));\n          }\n          break;\n        }\n      default:\n        {\n          shouldPreventDefault = false;\n        }\n    }\n    if (shouldPreventDefault) {\n      event.preventDefault();\n    }\n  }, [apiRef, currentPageRows, goToCell, goToHeader, getRowIdFromIndex]);\n  var handleColumnHeaderKeyDown = React.useCallback(function (params, event) {\n    var headerTitleNode = event.currentTarget.querySelector(\".\".concat(gridClasses.columnHeaderTitleContainerContent));\n    var isFromInsideContent = !!headerTitleNode && headerTitleNode.contains(event.target);\n    if (isFromInsideContent && params.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field) {\n      // When focus is on a nested input, keyboard events have no effect to avoid conflicts with native events.\n      // There is one exception for the checkBoxHeader\n      return;\n    }\n    var dimensions = apiRef.current.getRootDimensions();\n    if (!dimensions) {\n      return;\n    }\n    var viewportPageSize = apiRef.current.unstable_getViewportPageSize();\n    var colIndexBefore = params.field ? apiRef.current.getColumnIndex(params.field) : 0;\n    var firstRowIndexInPage = 0;\n    var lastRowIndexInPage = currentPageRows.length - 1;\n    var firstColIndex = 0;\n    var lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;\n    var shouldPreventDefault = true;\n    switch (event.key) {\n      case 'ArrowDown':\n        {\n          if (firstRowIndexInPage !== null) {\n            goToCell(colIndexBefore, getRowIdFromIndex(firstRowIndexInPage));\n          }\n          break;\n        }\n      case 'ArrowRight':\n        {\n          if (colIndexBefore < lastColIndex) {\n            goToHeader(colIndexBefore + 1, event);\n          }\n          break;\n        }\n      case 'ArrowLeft':\n        {\n          if (colIndexBefore > firstColIndex) {\n            goToHeader(colIndexBefore - 1, event);\n          }\n          break;\n        }\n      case 'PageDown':\n        {\n          if (firstRowIndexInPage !== null && lastRowIndexInPage !== null) {\n            goToCell(colIndexBefore, getRowIdFromIndex(Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage)));\n          }\n          break;\n        }\n      case 'Home':\n        {\n          goToHeader(firstColIndex, event);\n          break;\n        }\n      case 'End':\n        {\n          goToHeader(lastColIndex, event);\n          break;\n        }\n      case 'Enter':\n        {\n          if (event.ctrlKey || event.metaKey) {\n            apiRef.current.toggleColumnMenu(params.field);\n          }\n          break;\n        }\n      case ' ':\n        {\n          // prevent Space event from scrolling\n          break;\n        }\n      default:\n        {\n          shouldPreventDefault = false;\n        }\n    }\n    if (shouldPreventDefault) {\n      event.preventDefault();\n    }\n  }, [apiRef, currentPageRows, goToCell, goToHeader, getRowIdFromIndex]);\n  var handleCellKeyDown = React.useCallback(function (params, event) {\n    // Ignore portal\n    if (!event.currentTarget.contains(event.target)) {\n      return;\n    } // Get the most recent params because the cell mode may have changed by another listener\n\n    var cellParams = apiRef.current.getCellParams(params.id, params.field);\n    if (cellParams.cellMode !== GridCellModes.Edit && isNavigationKey(event.key)) {\n      apiRef.current.publishEvent('cellNavigationKeyDown', cellParams, event);\n    }\n  }, [apiRef]);\n  useGridApiEventHandler(apiRef, 'cellNavigationKeyDown', handleCellNavigationKeyDown);\n  useGridApiEventHandler(apiRef, 'columnHeaderKeyDown', handleColumnHeaderKeyDown);\n  useGridApiEventHandler(apiRef, 'cellKeyDown', handleCellKeyDown);\n};","map":null,"metadata":{},"sourceType":"module"}